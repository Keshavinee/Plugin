Developing mobile app to download the zip files, unzip and store from server while the device is locked/running

We were instructed to learn about Node, AngularJS, Ionic setup, Javascript basics, and the Ionic framework.To understand the fundamentals, we developed a simple Ionic app. We have also learnt Android Studio.Following that, we had a meeting with our seniors who had created an ionic app utilizing the Cordova plugin for downloading files in the background from firebase.They told us what they had done and what we could do next.The code was given by seniors, and we looked over each function and module to understand their approach.Then we met with our professors to go over our comprehension of the project and clear up any confusions.Professors asked us to simulate the crashing scenario in order to comprehend the project's flaws and identify areas for development.

Meeting with the caterpillar was conducted where we introduced ourselves and they explained to us the problem statement. They asked us to explore writing native plugins rather than using cordova plugin which has limitations. 
  
                            We simulated the crashing scenario in four different devices and following results were obtained:

Total number of downloads : 1920
 
Model
Before Solution
Time taken
After solution
Time taken 
Vivo
150
15 mins
635
20 mins
Oneplus
48
5 mins
336
30 mins
Redmi
379
37 mins
683
53 mins
Samsung
972
2 hrs
1920
3 hrs


Then we started exploring about native plugins in different frameworks. We learned about React Native background service library for running background tasks forever in Android and iOS and Schedule a background job that will run javascript when the app is in the background or foreground.Then we explored React Native background tasks with headless JS. React Native uses headless JS to execute Javascript code in the background. We dropped the plan of using React native because it was infeasible to convert React Native plugin to Ionic Plugin. We read the android documentation stating that the system cannot have wakelocks or job schedulers. Android doesn’t allow us to use wakelocks when the phone is asleep. Seniors used wakelock in their code which could be one of the reasons why some devices didn’t support the application. Initially we started with the process of writing native plugin but we found it very tedious to write a plugin of our own. We couldn't understand the plugin writing process and we were unaware of what all modules to be included. 
                
                      Then we came across the Work Manager Library. WorkManager is the primary recommended API for background processing.WorkManager handles three types of persistent work:

Immediate: Tasks that must begin immediately and complete soon. May be expedited.
Long Running: Tasks which might run for longer, potentially longer than 10 minutes.
Deferrable: Scheduled tasks that start at a later time and can run periodically.
With all the explored information, another meeting was scheduled with the caterpillar. We explained all our explored learnings and expressed our views on writing native plugins. We then told them about the Work Manager. We explained to them about workmanager and its features. They asked us to develop a simple app with workmanager. 
We began working on a basic app using workmanager.We proceeded with a long-running job with periodic work requests. We added only a notification in the work function where notification manager is used to display the notification for an hour even after the app is closed. This ensures that the app is running in the background. We tested this app on our mobile. Then we scheduled another meeting to show the demo of the workmanager app.
                        We demonstrated the app and described how the notification is queued in the background. We showed the source code and explained how background processes were initiated and cancelled.We spoke about the halt background process problem. Sathish sir outlined the problems with the stop process and advised us to consider the following use case later.Sir outlined the three layers that must be completed:API call for downloading the file, reading it, and inserting the metadata into the database.
                      In the work function, we removed the notification part and added the background downloading process. First we connected android studio with Firebase and added appropriate SDK dependencies. We ensured that the android studio and firebase are connected properly. Then we uploaded a 77 Mb Zip file to firebase. We created a reference for firebase storage and included firebase link in getReferenceFromurl function. Then we instantiated child reference for the zip file uploaded in the firebase. We created a local file named work.zip and copied the content to the local file through a reference pointer.
We extracted files from the zip file using zipInputStream function. We traversed through the files, copied the file content to a temporary file of appropriate file extension. The extension was returned by the zipInputStream.nextEntry variable. The file name and path of the temporary file is inserted  into SQLite Database. Database was created using the Database Helper . Database has only one relation with following attributes:
ID
Filename
Filepath 
We tested this on VIVO V2029 and it worked as expected. Then we uploaded a 256.38MB Zip file which contains 1161 files(pptx,png,pdf,zip). 
We scheduled the meeting to demonstrate the working of the application. During the meeting, we were asked to implement the following features:
Multiple downloads from the firebase at a time
Displaying multiple notifications for files getting downloaded and inserting into database
Also, we were informed to validate the application on different android devices. We were already able to achieve the first one where multiple zip files downloaded from firebase moved to the code cache of the application. And then the zip files are extracted and inserted into the database one after another. To achieve the second one, we added the NotificationManager class and a variable notificationCounter. The variable gets incremented by 1 each time when the “RUN BACKGROUND TASK” button is pressed. This helps to create a unique notification id for each zip file and establishes multiple notification channels. The displayed notification will contain following text:
File <<number>> : Downloaded from firebase
File <<number>> : <<Number of files>> inserted into database
After adding these two features, we tested our application on different mobile brands and noted the time taken to get all the files inserted into our database.

Brands
Time taken 
Vivo
(3.53pm-4:01pm) 8 mins
Oneplus Nord 2T
(6.33pm-6.37pm) 4 mins
samsung
Database not created
Oneplus 8
(12.00pm-12.01pm) 1min
Redmi note 9 pro
(11.52am-12.04pm) 12mins
Redmi note 12 pro 
11.56am-12.04pm 8mins






Zip file size : 449.95 MB 
No. of files inside a zip file : 1177 
Brands
Ram size (GB)
bandwidth(Mbps) download/upload
Average Time taken (3 times)
Apps running
OnePlus Nord 2T
8
4.20
4 + 5 + 4 = 4.33
Spotify, whatsapp, instagram, google search, youtube, phone call
Vivo V2029
4
26.4 / 33.6
3 + 2 + 2 = 2.33
Wynk, whatsapp, google search, youtube, phone call, teams
Realme Narzo 10
4
4.56 / 1.70
low bandwidth
Spotify, whatsapp, instagram, google search, youtube, phone call
OnePlus 8
8
1.39 / 1.52
low bandwidth
Spotify, whatsapp, instagram, zomato, files, clock
Samsung galaxy M31s
8
2.17/3.23
low bandwidth
WhatsApp,Spotify, instagram,LinkedIn, angry bird game, yatra, browser, make my trip,teams
One plus nord2 5G
8
13.3/0.41
low bandwidth
Whatsapp,Spotify, Google lens,Snapchat,browser, zomato, files,clock,teams
Redmi note 10 lite
4
12.0/2.11
5 + 4 + 5 = 4.67
Whatsapp,google,youtube,
spotify,calendar,call,camera,music,
Google Pixel 6
8
3.7
low bandwidth
whatsapp,google,youtube,spotify,gpay,camera,Instagram


Steps we followed to create custom plugin and to integrate in an ionic application:
npx @capacitor/cli plugin:generate - This command generates the basic structure of custom plugin
The plugin has to be registered and code for registration has to be implemented in definitions.ts file present inside the src directory of the app (app/src/definitions.ts).
The web implementation of the plugin is provided in web.ts (app/src/web.ts) and index.ts exports the plugin interface.
ionic start devdacticPlugin blank –type=angular –capacitor - This command creates the ionic application
npm install custom-plugin-name - It installs a custom plugin inside an ionic application.
Once the plugin is installed, the methods of the plugin are used inside the application. The following method is invoked: ExamplePlugin['startWork']
import 'sample-plugin';
import { Plugins } from '@capacitor/core';
const { ExamplePlugin } = Plugins;

// default code
  async load(){
    await ExamplePlugin['startWork']();
  }
// default code
npx cap open android - The android implementation of ionic app is opened in android studio.
ExamplePlugin.class is called inside the main activity java file and firebase app is initialized.
The actual implementation of workmanager (java files) is added inside the android section of the custom plugin and necessary dependencies are included in app’s build.gradle file and project’s build.gradle file and finally executed and deployed the application.
